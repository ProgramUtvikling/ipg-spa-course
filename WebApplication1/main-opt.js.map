{
  "version": 3,
  "file": "C:/Users/Student/Documents/Visual Studio 2013/Projects/Playground/WebApplication1/main-opt.js",
  "sources": [
    "withLookups.js",
    "../bower_components/requirejs-domready/domready.js",
    "domready!",
    "../bower_components/knockout-projections/dist/knockout-projections.js",
    "../bower_components/knockout-mapping/build/output/knockout.mapping-latest.js",
    "MyKoUtils.js",
    "Data/Movies.js",
    "Components/MovieIndex.js",
    "Components/MovieDetail.js",
    "Main.js"
  ],
  "names": [],
  "mappings": "AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvBA,ADwBA;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AClIA;ACAA,ADCA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvYA,ADwYA;ACvYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjCA,ADkCA;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtEA,ADuEA;ACtEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjBA,ADkBA;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "sourcesContent": [
    "define('withLookups',[\"knockout\"], function (ko) {\r\n\treturn function () {\r\n\t\tko.bindingHandlers.withLookups = {\r\n\t\t\tinit: function (element, valueAccessor, allBindings, viewModel, bindingContext) {\r\n\t\t\t\tvar lookups = {};\r\n\t\t\t\tvar arrayOfLookupNames = valueAccessor();\r\n\t\t\t\trequire(arrayOfLookupNames, function () {\r\n\t\t\t\t\tfor (var i = 0; i < arguments.length; i++) {\r\n\t\t\t\t\t\tvar lookupModule = arguments[i];\r\n\t\t\t\t\t\tconsole.log(lookupModule.lookupFunctionName);\r\n\t\t\t\t\t\tlookups[lookupModule.lookupFunctionName] = lookupModule.lookupFunction;\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\r\n\t\t\t\tvar innerBindingContext = bindingContext.extend(lookups);\r\n\t\t\t\tko.applyBindingsToDescendants(innerBindingContext, element);\r\n\r\n\t\t\t\t//ko.virtualElements.allowedBindings.withLookups = true;\r\n\r\n\t\t\t\treturn { controlsDescendantBindings: true };\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n});\n",
    "/**\n * @license RequireJS domReady 2.0.1 Copyright (c) 2010-2012, The Dojo Foundation All Rights Reserved.\n * Available via the MIT or new BSD license.\n * see: http://github.com/requirejs/domReady for details\n */\n/*jslint */\n/*global require: false, define: false, requirejs: false,\n  window: false, clearInterval: false, document: false,\n  self: false, setInterval: false */\n\n\ndefine('domready',[],function () {\n    'use strict';\n\n    var isTop, testDiv, scrollIntervalId,\n        isBrowser = typeof window !== \"undefined\" && window.document,\n        isPageLoaded = !isBrowser,\n        doc = isBrowser ? document : null,\n        readyCalls = [];\n\n    function runCallbacks(callbacks) {\n        var i;\n        for (i = 0; i < callbacks.length; i += 1) {\n            callbacks[i](doc);\n        }\n    }\n\n    function callReady() {\n        var callbacks = readyCalls;\n\n        if (isPageLoaded) {\n            //Call the DOM ready callbacks\n            if (callbacks.length) {\n                readyCalls = [];\n                runCallbacks(callbacks);\n            }\n        }\n    }\n\n    /**\n     * Sets the page as loaded.\n     */\n    function pageLoaded() {\n        if (!isPageLoaded) {\n            isPageLoaded = true;\n            if (scrollIntervalId) {\n                clearInterval(scrollIntervalId);\n            }\n\n            callReady();\n        }\n    }\n\n    if (isBrowser) {\n        if (document.addEventListener) {\n            //Standards. Hooray! Assumption here that if standards based,\n            //it knows about DOMContentLoaded.\n            document.addEventListener(\"DOMContentLoaded\", pageLoaded, false);\n            window.addEventListener(\"load\", pageLoaded, false);\n        } else if (window.attachEvent) {\n            window.attachEvent(\"onload\", pageLoaded);\n\n            testDiv = document.createElement('div');\n            try {\n                isTop = window.frameElement === null;\n            } catch (e) {}\n\n            //DOMContentLoaded approximation that uses a doScroll, as found by\n            //Diego Perini: http://javascript.nwbox.com/IEContentLoaded/,\n            //but modified by other contributors, including jdalton\n            if (testDiv.doScroll && isTop && window.external) {\n                scrollIntervalId = setInterval(function () {\n                    try {\n                        testDiv.doScroll();\n                        pageLoaded();\n                    } catch (e) {}\n                }, 30);\n            }\n        }\n\n        //Check if document already complete, and if so, just trigger page load\n        //listeners. Latest webkit browsers also use \"interactive\", and\n        //will fire the onDOMContentLoaded before \"interactive\" but not after\n        //entering \"interactive\" or \"complete\". More details:\n        //http://dev.w3.org/html5/spec/the-end.html#the-end\n        //http://stackoverflow.com/questions/3665561/document-readystate-of-interactive-vs-ondomcontentloaded\n        //Hmm, this is more complicated on further use, see \"firing too early\"\n        //bug: https://github.com/requirejs/domReady/issues/1\n        //so removing the || document.readyState === \"interactive\" test.\n        //There is still a window.onload binding that should get fired if\n        //DOMContentLoaded is missed.\n        if (document.readyState === \"complete\") {\n            pageLoaded();\n        }\n    }\n\n    /** START OF PUBLIC API **/\n\n    /**\n     * Registers a callback for DOM ready. If DOM is already ready, the\n     * callback is called immediately.\n     * @param {Function} callback\n     */\n    function domReady(callback) {\n        if (isPageLoaded) {\n            callback(doc);\n        } else {\n            readyCalls.push(callback);\n        }\n        return domReady;\n    }\n\n    domReady.version = '2.0.1';\n\n    /**\n     * Loader Plugin API method\n     */\n    domReady.load = function (name, req, onLoad, config) {\n        if (config.isBuild) {\n            onLoad(null);\n        } else {\n            domReady(onLoad);\n        }\n    };\n\n    /** END OF PUBLIC API **/\n\n    return domReady;\n});\n\n",
    "\n",
    "/*! Knockout projections plugin - version 1.1.0\r\n------------------------------------------------------------------------------\r\nCopyright (c) Microsoft Corporation\r\nAll rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 \r\nTHIS CODE IS PROVIDED *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE, MERCHANTABLITY OR NON-INFRINGEMENT.\r\nSee the Apache Version 2.0 License for specific language governing permissions and limitations under the License.\r\n------------------------------------------------------------------------------\r\n*/\r\n\r\n(function(global, undefined) {\r\n    'use strict';\r\n\r\n    var exclusionMarker = {};\r\n\r\n    function StateItem(ko, inputItem, initialStateArrayIndex, initialOutputArrayIndex, mappingOptions, arrayOfState, outputObservableArray) {\r\n        // Capture state for later use\r\n        this.inputItem = inputItem;\r\n        this.stateArrayIndex = initialStateArrayIndex;\r\n        this.mappingOptions = mappingOptions;\r\n        this.arrayOfState = arrayOfState;\r\n        this.outputObservableArray = outputObservableArray;\r\n        this.outputArray = this.outputObservableArray.peek();\r\n        this.isIncluded = null; // Means 'not yet determined'\r\n        this.suppressNotification = false; // TODO: Instead of this technique, consider raising a sparse diff with a \"mutated\" entry when a single item changes, and not having any other change logic inside StateItem\r\n\r\n        // Set up observables\r\n        this.outputArrayIndex = ko.observable(initialOutputArrayIndex); // When excluded, it's the position the item would go if it became included\r\n        this.disposeFuncFromMostRecentMapping = null;\r\n        this.mappedValueComputed = ko.computed(this.mappingEvaluator, this);\r\n        this.mappedValueComputed.subscribe(this.onMappingResultChanged, this);\r\n        this.previousMappedValue = this.mappedValueComputed.peek();\r\n    }\r\n\r\n    StateItem.prototype.dispose = function() {\r\n        this.mappedValueComputed.dispose();\r\n        this.disposeResultFromMostRecentEvaluation();\r\n    };\r\n\r\n    StateItem.prototype.disposeResultFromMostRecentEvaluation = function() {\r\n        if (this.disposeFuncFromMostRecentMapping) {\r\n            this.disposeFuncFromMostRecentMapping();\r\n            this.disposeFuncFromMostRecentMapping = null;\r\n        }\r\n\r\n        if (this.mappingOptions.disposeItem) {\r\n            var mappedItem = this.mappedValueComputed();\r\n            this.mappingOptions.disposeItem(mappedItem);\r\n        }\r\n    };\r\n\r\n    StateItem.prototype.mappingEvaluator = function() {\r\n        if (this.isIncluded !== null) { // i.e., not first run\r\n            // This is a replace-in-place, so call any dispose callbacks\r\n            // we have for the earlier value\r\n            this.disposeResultFromMostRecentEvaluation();\r\n        }\r\n\r\n        var mappedValue;\r\n        if (this.mappingOptions.mapping) {\r\n            mappedValue = this.mappingOptions.mapping(this.inputItem, this.outputArrayIndex);\r\n        } else if (this.mappingOptions.mappingWithDisposeCallback) {\r\n            var mappedValueWithDisposeCallback = this.mappingOptions.mappingWithDisposeCallback(this.inputItem, this.outputArrayIndex);\r\n            if (!('mappedValue' in mappedValueWithDisposeCallback)) {\r\n                throw new Error('Return value from mappingWithDisposeCallback should have a \\'mappedItem\\' property.');\r\n            }\r\n            mappedValue = mappedValueWithDisposeCallback.mappedValue;\r\n            this.disposeFuncFromMostRecentMapping = mappedValueWithDisposeCallback.dispose;\r\n        } else {\r\n            throw new Error('No mapping callback given.');\r\n        }\r\n\r\n        var newInclusionState = mappedValue !== exclusionMarker;\r\n\r\n        // Inclusion state changes can *only* happen as a result of changing an individual item.\r\n        // Structural changes to the array can't cause this (because they don't cause any remapping;\r\n        // they only map newly added items which have no earlier inclusion state to change).\r\n        if (this.isIncluded !== newInclusionState) {\r\n            if (this.isIncluded !== null) { // i.e., not first run\r\n                this.moveSubsequentItemsBecauseInclusionStateChanged(newInclusionState);\r\n            }\r\n\r\n            this.isIncluded = newInclusionState;\r\n        }\r\n\r\n        return mappedValue;\r\n    };\r\n\r\n    StateItem.prototype.onMappingResultChanged = function(newValue) {\r\n        if (newValue !== this.previousMappedValue) {\r\n            if (this.isIncluded) {\r\n                this.outputArray.splice(this.outputArrayIndex.peek(), 1, newValue);\r\n            }\r\n\r\n            if (!this.suppressNotification) {\r\n                this.outputObservableArray.valueHasMutated();\r\n            }\r\n\r\n            this.previousMappedValue = newValue;\r\n        }\r\n    };\r\n\r\n    StateItem.prototype.moveSubsequentItemsBecauseInclusionStateChanged = function(newInclusionState) {\r\n        var outputArrayIndex = this.outputArrayIndex.peek(),\r\n            iterationIndex,\r\n            stateItem;\r\n\r\n        if (newInclusionState) {\r\n            // Shift all subsequent items along by one space, and increment their indexes.\r\n            // Note that changing their indexes might cause remapping, but won't affect their\r\n            // inclusion status (by definition, inclusion status must not be affected by index,\r\n            // otherwise you get undefined results) so there's no risk of a chain reaction.\r\n            this.outputArray.splice(outputArrayIndex, 0, null);\r\n            for (iterationIndex = this.stateArrayIndex + 1; iterationIndex < this.arrayOfState.length; iterationIndex++) {\r\n                stateItem = this.arrayOfState[iterationIndex];\r\n                stateItem.setOutputArrayIndexSilently(stateItem.outputArrayIndex.peek() + 1);\r\n            }\r\n        } else {\r\n            // Shift all subsequent items back by one space, and decrement their indexes\r\n            this.outputArray.splice(outputArrayIndex, 1);\r\n            for (iterationIndex = this.stateArrayIndex + 1; iterationIndex < this.arrayOfState.length; iterationIndex++) {\r\n                stateItem = this.arrayOfState[iterationIndex];\r\n                stateItem.setOutputArrayIndexSilently(stateItem.outputArrayIndex.peek() - 1);\r\n            }\r\n        }\r\n    };\r\n\r\n    StateItem.prototype.setOutputArrayIndexSilently = function(newIndex) {\r\n        // We only want to raise one output array notification per input array change,\r\n        // so during processing, we suppress notifications\r\n        this.suppressNotification = true;\r\n        this.outputArrayIndex(newIndex);\r\n        this.suppressNotification = false;\r\n    };\r\n\r\n    function getDiffEntryPostOperationIndex(diffEntry, editOffset) {\r\n        // The diff algorithm's \"index\" value refers to the output array for additions,\r\n        // but the \"input\" array for deletions. Get the output array position.\r\n        if (!diffEntry) { return null; }\r\n        switch (diffEntry.status) {\r\n        case 'added':\r\n            return diffEntry.index;\r\n        case 'deleted':\r\n            return diffEntry.index + editOffset;\r\n        default:\r\n            throw new Error('Unknown diff status: ' + diffEntry.status);\r\n        }\r\n    }\r\n\r\n    function insertOutputItem(ko, diffEntry, movedStateItems, stateArrayIndex, outputArrayIndex, mappingOptions, arrayOfState, outputObservableArray, outputArray) {\r\n        // Retain the existing mapped value if this is a move, otherwise perform mapping\r\n        var isMoved = typeof diffEntry.moved === 'number',\r\n            stateItem = isMoved ?\r\n                movedStateItems[diffEntry.moved] :\r\n                new StateItem(ko, diffEntry.value, stateArrayIndex, outputArrayIndex, mappingOptions, arrayOfState, outputObservableArray);\r\n        arrayOfState.splice(stateArrayIndex, 0, stateItem);\r\n        if (stateItem.isIncluded) {\r\n            outputArray.splice(outputArrayIndex, 0, stateItem.mappedValueComputed.peek());\r\n        }\r\n\r\n        // Update indexes\r\n        if (isMoved) {\r\n            // We don't change the index until *after* updating this item's position in outputObservableArray,\r\n            // because changing the index may trigger re-mapping, which in turn would cause the new\r\n            // value to be written to the 'index' position in the output array\r\n            stateItem.stateArrayIndex = stateArrayIndex;\r\n            stateItem.setOutputArrayIndexSilently(outputArrayIndex);\r\n        }\r\n\r\n        return stateItem;\r\n    }\r\n\r\n    function deleteOutputItem(diffEntry, arrayOfState, stateArrayIndex, outputArrayIndex, outputArray) {\r\n        var stateItem = arrayOfState.splice(stateArrayIndex, 1)[0];\r\n        if (stateItem.isIncluded) {\r\n            outputArray.splice(outputArrayIndex, 1);\r\n        }\r\n        if (typeof diffEntry.moved !== 'number') {\r\n            // Be careful to dispose only if this item really was deleted and not moved\r\n            stateItem.dispose();\r\n        }\r\n    }\r\n\r\n    function updateRetainedOutputItem(stateItem, stateArrayIndex, outputArrayIndex) {\r\n        // Just have to update its indexes\r\n        stateItem.stateArrayIndex = stateArrayIndex;\r\n        stateItem.setOutputArrayIndexSilently(outputArrayIndex);\r\n\r\n        // Return the new value for outputArrayIndex\r\n        return outputArrayIndex + (stateItem.isIncluded ? 1 : 0);\r\n    }\r\n\r\n    function makeLookupOfMovedStateItems(diff, arrayOfState) {\r\n        // Before we mutate arrayOfComputedMappedValues at all, grab a reference to each moved item\r\n        var movedStateItems = {};\r\n        for (var diffIndex = 0; diffIndex < diff.length; diffIndex++) {\r\n            var diffEntry = diff[diffIndex];\r\n            if (diffEntry.status === 'added' && (typeof diffEntry.moved === 'number')) {\r\n                movedStateItems[diffEntry.moved] = arrayOfState[diffEntry.moved];\r\n            }\r\n        }\r\n        return movedStateItems;\r\n    }\r\n\r\n    function getFirstModifiedOutputIndex(firstDiffEntry, arrayOfState, outputArray) {\r\n        // Work out where the first edit will affect the output array\r\n        // Then we can update outputArrayIndex incrementally while walking the diff list\r\n        if (!outputArray.length || !arrayOfState[firstDiffEntry.index]) {\r\n            // The first edit is beyond the end of the output or state array, so we must\r\n            // just be appending items.\r\n            return outputArray.length;\r\n        } else {\r\n            // The first edit corresponds to an existing state array item, so grab\r\n            // the first output array index from it.\r\n            return arrayOfState[firstDiffEntry.index].outputArrayIndex.peek();\r\n        }\r\n    }\r\n\r\n    function respondToArrayStructuralChanges(ko, inputObservableArray, arrayOfState, outputArray, outputObservableArray, mappingOptions) {\r\n        return inputObservableArray.subscribe(function(diff) {\r\n            if (!diff.length) {\r\n                return;\r\n            }\r\n\r\n            var movedStateItems = makeLookupOfMovedStateItems(diff, arrayOfState),\r\n                diffIndex = 0,\r\n                diffEntry = diff[0],\r\n                editOffset = 0, // A running total of (num(items added) - num(items deleted)) not accounting for filtering\r\n                outputArrayIndex = diffEntry && getFirstModifiedOutputIndex(diffEntry, arrayOfState, outputArray);\r\n\r\n            // Now iterate over the state array, at each stage checking whether the current item\r\n            // is the next one to have been edited. We can skip all the state array items whose\r\n            // indexes are less than the first edit index (i.e., diff[0].index).\r\n            for (var stateArrayIndex = diffEntry.index; diffEntry || (stateArrayIndex < arrayOfState.length); stateArrayIndex++) {\r\n                // Does the current diffEntry correspond to this position in the state array?\r\n                if (getDiffEntryPostOperationIndex(diffEntry, editOffset) === stateArrayIndex) {\r\n                    // Yes - insert or delete the corresponding state and output items\r\n                    switch (diffEntry.status) {\r\n                    case 'added':\r\n                        // Add to output, and update indexes\r\n                        var stateItem = insertOutputItem(ko, diffEntry, movedStateItems, stateArrayIndex, outputArrayIndex, mappingOptions, arrayOfState, outputObservableArray, outputArray);\r\n                        if (stateItem.isIncluded) {\r\n                            outputArrayIndex++;\r\n                        }\r\n                        editOffset++;\r\n                        break;\r\n                    case 'deleted':\r\n                        // Just erase from the output, and update indexes\r\n                        deleteOutputItem(diffEntry, arrayOfState, stateArrayIndex, outputArrayIndex, outputArray);\r\n                        editOffset--;\r\n                        stateArrayIndex--; // To compensate for the \"for\" loop incrementing it\r\n                        break;\r\n                    default:\r\n                        throw new Error('Unknown diff status: ' + diffEntry.status);\r\n                    }\r\n\r\n                    // We're done with this diff entry. Move on to the next one.\r\n                    diffIndex++;\r\n                    diffEntry = diff[diffIndex];\r\n                } else if (stateArrayIndex < arrayOfState.length) {\r\n                    // No - the current item was retained. Just update its index.\r\n                    outputArrayIndex = updateRetainedOutputItem(arrayOfState[stateArrayIndex], stateArrayIndex, outputArrayIndex);\r\n                }\r\n            }\r\n\r\n            outputObservableArray.valueHasMutated();\r\n        }, null, 'arrayChange');\r\n    }\r\n\r\n    // Mapping\r\n    function observableArrayMap(ko, mappingOptions) {\r\n        var inputObservableArray = this,\r\n            arrayOfState = [],\r\n            outputArray = [],\r\n            outputObservableArray = ko.observableArray(outputArray),\r\n            originalInputArrayContents = inputObservableArray.peek();\r\n\r\n        // Shorthand syntax - just pass a function instead of an options object\r\n        if (typeof mappingOptions === 'function') {\r\n            mappingOptions = { mapping: mappingOptions };\r\n        }\r\n\r\n        // Validate the options\r\n        if (mappingOptions.mappingWithDisposeCallback) {\r\n            if (mappingOptions.mapping || mappingOptions.disposeItem) {\r\n                throw new Error('\\'mappingWithDisposeCallback\\' cannot be used in conjunction with \\'mapping\\' or \\'disposeItem\\'.');\r\n            }\r\n        } else if (!mappingOptions.mapping) {\r\n            throw new Error('Specify either \\'mapping\\' or \\'mappingWithDisposeCallback\\'.');\r\n        }\r\n\r\n        // Initial state: map each of the inputs\r\n        for (var i = 0; i < originalInputArrayContents.length; i++) {\r\n            var inputItem = originalInputArrayContents[i],\r\n                stateItem = new StateItem(ko, inputItem, i, outputArray.length, mappingOptions, arrayOfState, outputObservableArray),\r\n                mappedValue = stateItem.mappedValueComputed.peek();\r\n            arrayOfState.push(stateItem);\r\n\r\n            if (stateItem.isIncluded) {\r\n                outputArray.push(mappedValue);\r\n            }\r\n        }\r\n\r\n        // If the input array changes structurally (items added or removed), update the outputs\r\n        var inputArraySubscription = respondToArrayStructuralChanges(ko, inputObservableArray, arrayOfState, outputArray, outputObservableArray, mappingOptions);\r\n\r\n        // Return value is a readonly computed which can track its own changes to permit chaining.\r\n        // When disposed, it cleans up everything it created.\r\n        var returnValue = ko.computed(outputObservableArray).extend({ trackArrayChanges: true }),\r\n            originalDispose = returnValue.dispose;\r\n        returnValue.dispose = function() {\r\n            inputArraySubscription.dispose();\r\n            ko.utils.arrayForEach(arrayOfState, function(stateItem) {\r\n                stateItem.dispose();\r\n            });\r\n            originalDispose.call(this, arguments);\r\n        };\r\n\r\n        // Make projections chainable\r\n        addProjectionFunctions(ko, returnValue);\r\n\r\n        return returnValue;\r\n    }\r\n\r\n    // Filtering\r\n    function observableArrayFilter(ko, predicate) {\r\n        return observableArrayMap.call(this, ko, function(item) {\r\n            return predicate(item) ? item : exclusionMarker;\r\n        });\r\n    }\r\n\r\n    // Attaching projection functions\r\n    // ------------------------------\r\n    //\r\n    // Builds a collection of projection functions that can quickly be attached to any object.\r\n    // The functions are predefined to retain 'this' and prefix the arguments list with the\r\n    // relevant 'ko' instance.\r\n\r\n    var projectionFunctionsCacheName = '_ko.projections.cache';\r\n\r\n    function attachProjectionFunctionsCache(ko) {\r\n        // Wraps callback so that, when invoked, its arguments list is prefixed by 'ko' and 'this' \r\n        function makeCaller(ko, callback) {\r\n            return function() {\r\n                return callback.apply(this, [ko].concat(Array.prototype.slice.call(arguments, 0)));\r\n            };\r\n        }\r\n        ko[projectionFunctionsCacheName] = {\r\n            map: makeCaller(ko, observableArrayMap),\r\n            filter: makeCaller(ko, observableArrayFilter)\r\n        };\r\n    }\r\n\r\n    function addProjectionFunctions(ko, target) {\r\n        ko.utils.extend(target, ko[projectionFunctionsCacheName]);\r\n        return target; // Enable chaining\r\n    }\r\n\r\n    // Module initialisation\r\n    // ---------------------\r\n    //\r\n    // When this script is first evaluated, it works out what kind of module loading scenario\r\n    // it is in (Node.js or a browser `<script>` tag), and then attaches itself to whichever\r\n    // instance of Knockout.js it can find.\r\n\r\n    function attachToKo(ko) {\r\n        ko.projections = {\r\n            _exclusionMarker: exclusionMarker\r\n        };\r\n        attachProjectionFunctionsCache(ko);\r\n        addProjectionFunctions(ko, ko.observableArray.fn); // Make all observable arrays projectable\r\n    }\r\n\r\n    // Determines which module loading scenario we're in, grabs dependencies, and attaches to KO\r\n    function prepareExports() {\r\n        if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {\r\n            // Node.js case - load KO synchronously\r\n            var ko = require('knockout');\r\n            attachToKo(ko);\r\n            module.exports = ko;\r\n        } else if (typeof define === 'function' && define.amd) {\r\n            define('koprojections',['knockout'], attachToKo);\r\n        } else if ('ko' in global) {\r\n            // Non-module case - attach to the global instance\r\n            attachToKo(global.ko);\r\n        }\r\n    }\r\n\r\n    prepareExports();\r\n\r\n})(this);\r\n\n",
    "/// Knockout Mapping plugin v2.4.1\n/// (c) 2013 Steven Sanderson, Roy Jacobs - http://knockoutjs.com/\n/// License: MIT (http://www.opensource.org/licenses/mit-license.php)\n(function(e){\"function\"===typeof require&&\"object\"===typeof exports&&\"object\"===typeof module?e(require(\"knockout\"),exports):\"function\"===typeof define&&define.amd?define('komapping',[\"knockout\",\"exports\"],e):e(ko,ko.mapping={})})(function(e,f){function y(b,c){var a,d;for(d in c)if(c.hasOwnProperty(d)&&c[d])if(a=f.getType(b[d]),d&&b[d]&&\"array\"!==a&&\"string\"!==a)y(b[d],c[d]);else if(\"array\"===f.getType(b[d])&&\"array\"===f.getType(c[d])){a=b;for(var e=d,l=b[d],n=c[d],t={},g=l.length-1;0<=g;--g)t[l[g]]=l[g];for(g=\nn.length-1;0<=g;--g)t[n[g]]=n[g];l=[];n=void 0;for(n in t)l.push(t[n]);a[e]=l}else b[d]=c[d]}function E(b,c){var a={};y(a,b);y(a,c);return a}function z(b,c){for(var a=E({},b),e=L.length-1;0<=e;e--){var f=L[e];a[f]&&(a[\"\"]instanceof Object||(a[\"\"]={}),a[\"\"][f]=a[f],delete a[f])}c&&(a.ignore=h(c.ignore,a.ignore),a.include=h(c.include,a.include),a.copy=h(c.copy,a.copy),a.observe=h(c.observe,a.observe));a.ignore=h(a.ignore,j.ignore);a.include=h(a.include,j.include);a.copy=h(a.copy,j.copy);a.observe=h(a.observe,\nj.observe);a.mappedProperties=a.mappedProperties||{};a.copiedProperties=a.copiedProperties||{};return a}function h(b,c){\"array\"!==f.getType(b)&&(b=\"undefined\"===f.getType(b)?[]:[b]);\"array\"!==f.getType(c)&&(c=\"undefined\"===f.getType(c)?[]:[c]);return e.utils.arrayGetDistinctValues(b.concat(c))}function F(b,c,a,d,k,l,n){var t=\"array\"===f.getType(e.utils.unwrapObservable(c));l=l||\"\";if(f.isMapped(b)){var g=e.utils.unwrapObservable(b)[p];a=E(g,a)}var j=n||k,h=function(){return a[d]&&a[d].create instanceof\nFunction},x=function(b){var f=G,g=e.dependentObservable;e.dependentObservable=function(a,b,c){c=c||{};a&&\"object\"==typeof a&&(c=a);var d=c.deferEvaluation,M=!1;c.deferEvaluation=!0;a=new H(a,b,c);if(!d){var g=a,d=e.dependentObservable;e.dependentObservable=H;a=e.isWriteableObservable(g);e.dependentObservable=d;d=H({read:function(){M||(e.utils.arrayRemoveItem(f,g),M=!0);return g.apply(g,arguments)},write:a&&function(a){return g(a)},deferEvaluation:!0});d.__DO=g;a=d;f.push(a)}return a};e.dependentObservable.fn=\nH.fn;e.computed=e.dependentObservable;b=e.utils.unwrapObservable(k)instanceof Array?a[d].create({data:b||c,parent:j,skip:N}):a[d].create({data:b||c,parent:j});e.dependentObservable=g;e.computed=e.dependentObservable;return b},u=function(){return a[d]&&a[d].update instanceof Function},v=function(b,f){var g={data:f||c,parent:j,target:e.utils.unwrapObservable(b)};e.isWriteableObservable(b)&&(g.observable=b);return a[d].update(g)};if(n=I.get(c))return n;d=d||\"\";if(t){var t=[],s=!1,m=function(a){return a};\na[d]&&a[d].key&&(m=a[d].key,s=!0);e.isObservable(b)||(b=e.observableArray([]),b.mappedRemove=function(a){var c=\"function\"==typeof a?a:function(b){return b===m(a)};return b.remove(function(a){return c(m(a))})},b.mappedRemoveAll=function(a){var c=C(a,m);return b.remove(function(a){return-1!=e.utils.arrayIndexOf(c,m(a))})},b.mappedDestroy=function(a){var c=\"function\"==typeof a?a:function(b){return b===m(a)};return b.destroy(function(a){return c(m(a))})},b.mappedDestroyAll=function(a){var c=C(a,m);return b.destroy(function(a){return-1!=\ne.utils.arrayIndexOf(c,m(a))})},b.mappedIndexOf=function(a){var c=C(b(),m);a=m(a);return e.utils.arrayIndexOf(c,a)},b.mappedGet=function(a){return b()[b.mappedIndexOf(a)]},b.mappedCreate=function(a){if(-1!==b.mappedIndexOf(a))throw Error(\"There already is an object with the key that you specified.\");var c=h()?x(a):a;u()&&(a=v(c,a),e.isWriteableObservable(c)?c(a):c=a);b.push(c);return c});n=C(e.utils.unwrapObservable(b),m).sort();g=C(c,m);s&&g.sort();s=e.utils.compareArrays(n,g);n={};var J,A=e.utils.unwrapObservable(c),\ny={},z=!0,g=0;for(J=A.length;g<J;g++){var r=m(A[g]);if(void 0===r||r instanceof Object){z=!1;break}y[r]=A[g]}var A=[],B=0,g=0;for(J=s.length;g<J;g++){var r=s[g],q,w=l+\"[\"+g+\"]\";switch(r.status){case \"added\":var D=z?y[r.value]:K(e.utils.unwrapObservable(c),r.value,m);q=F(void 0,D,a,d,b,w,k);h()||(q=e.utils.unwrapObservable(q));w=O(e.utils.unwrapObservable(c),D,n);q===N?B++:A[w-B]=q;n[w]=!0;break;case \"retained\":D=z?y[r.value]:K(e.utils.unwrapObservable(c),r.value,m);q=K(b,r.value,m);F(q,D,a,d,b,w,\nk);w=O(e.utils.unwrapObservable(c),D,n);A[w]=q;n[w]=!0;break;case \"deleted\":q=K(b,r.value,m)}t.push({event:r.status,item:q})}b(A);a[d]&&a[d].arrayChanged&&e.utils.arrayForEach(t,function(b){a[d].arrayChanged(b.event,b.item)})}else if(P(c)){b=e.utils.unwrapObservable(b);if(!b){if(h())return s=x(),u()&&(s=v(s)),s;if(u())return v(s);b={}}u()&&(b=v(b));I.save(c,b);if(u())return b;Q(c,function(d){var f=l.length?l+\".\"+d:d;if(-1==e.utils.arrayIndexOf(a.ignore,f))if(-1!=e.utils.arrayIndexOf(a.copy,f))b[d]=\nc[d];else if(\"object\"!=typeof c[d]&&\"array\"!=typeof c[d]&&0<a.observe.length&&-1==e.utils.arrayIndexOf(a.observe,f))b[d]=c[d],a.copiedProperties[f]=!0;else{var g=I.get(c[d]),k=F(b[d],c[d],a,d,b,f,b),g=g||k;if(0<a.observe.length&&-1==e.utils.arrayIndexOf(a.observe,f))b[d]=g(),a.copiedProperties[f]=!0;else{if(e.isWriteableObservable(b[d])){if(g=e.utils.unwrapObservable(g),b[d]()!==g)b[d](g)}else g=void 0===b[d]?g:e.utils.unwrapObservable(g),b[d]=g;a.mappedProperties[f]=!0}}})}else switch(f.getType(c)){case \"function\":u()?\ne.isWriteableObservable(c)?(c(v(c)),b=c):b=v(c):b=c;break;default:if(e.isWriteableObservable(b))return q=u()?v(b):e.utils.unwrapObservable(c),b(q),q;h()||u();b=h()?x():e.observable(e.utils.unwrapObservable(c));u()&&b(v(b))}return b}function O(b,c,a){for(var d=0,e=b.length;d<e;d++)if(!0!==a[d]&&b[d]===c)return d;return null}function R(b,c){var a;c&&(a=c(b));\"undefined\"===f.getType(a)&&(a=b);return e.utils.unwrapObservable(a)}function K(b,c,a){b=e.utils.unwrapObservable(b);for(var d=0,f=b.length;d<\nf;d++){var l=b[d];if(R(l,a)===c)return l}throw Error(\"When calling ko.update*, the key '\"+c+\"' was not found!\");}function C(b,c){return e.utils.arrayMap(e.utils.unwrapObservable(b),function(a){return c?R(a,c):a})}function Q(b,c){if(\"array\"===f.getType(b))for(var a=0;a<b.length;a++)c(a);else for(a in b)c(a)}function P(b){var c=f.getType(b);return(\"object\"===c||\"array\"===c)&&null!==b}function T(){var b=[],c=[];this.save=function(a,d){var f=e.utils.arrayIndexOf(b,a);0<=f?c[f]=d:(b.push(a),c.push(d))};\nthis.get=function(a){a=e.utils.arrayIndexOf(b,a);return 0<=a?c[a]:void 0}}function S(){var b={},c=function(a){var c;try{c=a}catch(e){c=\"$$$\"}a=b[c];void 0===a&&(a=new T,b[c]=a);return a};this.save=function(a,b){c(a).save(a,b)};this.get=function(a){return c(a).get(a)}}var p=\"__ko_mapping__\",H=e.dependentObservable,B=0,G,I,L=[\"create\",\"update\",\"key\",\"arrayChanged\"],N={},x={include:[\"_destroy\"],ignore:[],copy:[],observe:[]},j=x;f.isMapped=function(b){return(b=e.utils.unwrapObservable(b))&&b[p]};f.fromJS=\nfunction(b){if(0==arguments.length)throw Error(\"When calling ko.fromJS, pass the object you want to convert.\");try{B++||(G=[],I=new S);var c,a;2==arguments.length&&(arguments[1][p]?a=arguments[1]:c=arguments[1]);3==arguments.length&&(c=arguments[1],a=arguments[2]);a&&(c=E(c,a[p]));c=z(c);var d=F(a,b,c);a&&(d=a);if(!--B)for(;G.length;){var e=G.pop();e&&(e(),e.__DO.throttleEvaluation=e.throttleEvaluation)}d[p]=E(d[p],c);return d}catch(f){throw B=0,f;}};f.fromJSON=function(b){var c=e.utils.parseJson(b);\narguments[0]=c;return f.fromJS.apply(this,arguments)};f.updateFromJS=function(){throw Error(\"ko.mapping.updateFromJS, use ko.mapping.fromJS instead. Please note that the order of parameters is different!\");};f.updateFromJSON=function(){throw Error(\"ko.mapping.updateFromJSON, use ko.mapping.fromJSON instead. Please note that the order of parameters is different!\");};f.toJS=function(b,c){j||f.resetDefaultOptions();if(0==arguments.length)throw Error(\"When calling ko.mapping.toJS, pass the object you want to convert.\");\nif(\"array\"!==f.getType(j.ignore))throw Error(\"ko.mapping.defaultOptions().ignore should be an array.\");if(\"array\"!==f.getType(j.include))throw Error(\"ko.mapping.defaultOptions().include should be an array.\");if(\"array\"!==f.getType(j.copy))throw Error(\"ko.mapping.defaultOptions().copy should be an array.\");c=z(c,b[p]);return f.visitModel(b,function(a){return e.utils.unwrapObservable(a)},c)};f.toJSON=function(b,c){var a=f.toJS(b,c);return e.utils.stringifyJson(a)};f.defaultOptions=function(){if(0<arguments.length)j=\narguments[0];else return j};f.resetDefaultOptions=function(){j={include:x.include.slice(0),ignore:x.ignore.slice(0),copy:x.copy.slice(0)}};f.getType=function(b){if(b&&\"object\"===typeof b){if(b.constructor===Date)return\"date\";if(b.constructor===Array)return\"array\"}return typeof b};f.visitModel=function(b,c,a){a=a||{};a.visitedObjects=a.visitedObjects||new S;var d,k=e.utils.unwrapObservable(b);if(P(k))a=z(a,k[p]),c(b,a.parentName),d=\"array\"===f.getType(k)?[]:{};else return c(b,a.parentName);a.visitedObjects.save(b,\nd);var l=a.parentName;Q(k,function(b){if(!(a.ignore&&-1!=e.utils.arrayIndexOf(a.ignore,b))){var j=k[b],g=a,h=l||\"\";\"array\"===f.getType(k)?l&&(h+=\"[\"+b+\"]\"):(l&&(h+=\".\"),h+=b);g.parentName=h;if(!(-1===e.utils.arrayIndexOf(a.copy,b)&&-1===e.utils.arrayIndexOf(a.include,b)&&k[p]&&k[p].mappedProperties&&!k[p].mappedProperties[b]&&k[p].copiedProperties&&!k[p].copiedProperties[b]&&\"array\"!==f.getType(k)))switch(f.getType(e.utils.unwrapObservable(j))){case \"object\":case \"array\":case \"undefined\":g=a.visitedObjects.get(j);\nd[b]=\"undefined\"!==f.getType(g)?g:f.visitModel(j,c,a);break;default:d[b]=c(j,a.parentName)}}});return d}});\n\n",
    "define('MyKoUtils',[\"knockout\", \"komapping\"], function(ko, komapping) {\r\n\t\"use strict\";\r\n\r\n\tvar func = function (from, to) {\r\n\t\tvar unwrapped = komapping.toJS(from);\r\n\t\treturn komapping.fromJS(unwrapped, {}, to);\r\n\r\n\t\t//to = to || {};\r\n\t\t//for (var propertyname in from) {\r\n\t\t//\tif (from.hasOwnProperty(propertyname) && propertyname.indexOf('__') !== 0) {\r\n\r\n\t\t//\t\t// Get value either from normal property, or from observable\r\n\t\t//\t\tvar value = ko.isObservable(from[propertyname]) ?\r\n\t\t//\t\t\tfrom[propertyname]() : from[propertyname];\r\n\r\n\t\t//\t\t// Set value in one of these ways: exisiting observable,\r\n\t\t//\t\t//   existing property or a new observable\r\n\t\t//\t\tif (to[propertyname] === undefined) {\r\n\t\t//\t\t\tto[propertyname] = ko.observable(value);\r\n\t\t//\t\t} else if (ko.isObservable(to[propertyname])) {\r\n\t\t//\t\t\tto[propertyname](value);\r\n\t\t//\t\t} else {\r\n\t\t//\t\t\tto[propertyname] = value;\r\n\t\t//\t\t}\r\n\t\t//\t}\r\n\t\t//}\r\n\t\t//return to;\r\n\t};\r\n\r\n\treturn {\r\n\t\tcopy: func,\r\n\t\tmergeInto: func,\r\n}\r\n});\n",
    "define('Data/Movies',[\"jquery\", \"knockout\", \"komapping\", \"MyKoUtils\"], function ($, ko, komapping, myKoUtils) {\r\n\t\"use strict\";\r\n\r\n\tvar isLoaded = false;\r\n\tvar movies = ko.observableArray();\r\n\r\n\tvar ensureLoaded = function () {\r\n\t\tvar deferredObject = $.Deferred();\r\n\t\tif (isLoaded) {\r\n\t\t\tdeferredObject.resolve();\r\n\t\t} else {\r\n\t\t\t$.ajax({\r\n\t\t\t\turl: '/Api/Movie',\r\n\t\t\t\tmethod: 'GET'\r\n\t\t\t}).then(function (data) {\r\n\t\t\t\tdata.forEach(function (item) {\r\n\t\t\t\t\tmovies.push(komapping.fromJS(item));\r\n\t\t\t\t});\r\n\t\t\t\tdeferredObject.resolve();\r\n\t\t\t});\r\n\t\t\tisLoaded = true;\r\n\t\t}\r\n\r\n\t\treturn deferredObject.promise();\r\n\t};\r\n\r\n\r\n\tvar getMovies = function () {\r\n\t\tensureLoaded();\r\n\t\treturn movies;\r\n\t};\r\n\r\n\tvar getMovie = function (id) {\r\n\t\tvar movie = {\r\n\t\t\tid: ko.observable(),\r\n\t\t\ttitle: ko.observable(\"n/a\"),\r\n\t\t\tproductionYear: ko.observable(),\r\n\t\t\trunningLength: ko.observable(),\r\n\t\t\tvote: ko.observable()\r\n\t\t};\r\n\r\n\t\t$.ajax({\r\n\t\t\turl: '/Api/Movie/' + id,\r\n\t\t\tmethod: 'GET'\r\n\t\t}).then(function (data) {\r\n\t\t\tmyKoUtils.mergeInto(data, movie);\r\n\t\t\t//komapping.fromJS(data, {}, movie);\r\n\t\t});\r\n\r\n\t\treturn movie;\r\n\t};\r\n\r\n\tvar updateMovie = function (movie) {\r\n\t\t$.ajax({\r\n\t\t\turl: '/Api/Movie/' + movie.id(),\r\n\t\t\tmethod: \"PUT\",\r\n\t\t\tdata: komapping.toJSON(movie),\r\n\t\t\tdataType: 'json'\r\n\t\t}).then(function (data1, data2) {\r\n\t\t\talert(\"data1: \" + JSON.stringify(data1) + \"\\ndata2: \" + JSON.stringify(data2));\r\n\t\t}, function (err) {\r\n\t\t\talert(\"something went wrong: \" + JSON.stringify(err));\r\n\t\t});\r\n\t};\r\n\r\n\treturn {\r\n\t\tgetMovies: getMovies,\r\n\t\tgetMovie: getMovie,\r\n\t\tupdateMovie: updateMovie\r\n\t};\r\n});\n",
    "define('Components/MovieIndex',[\"knockout\", \"koprojections\", \"Data/Movies\"], function (ko, _, movieSvc) {\r\n\t\"use strict\";\r\n\r\n\tvar componentName = \"MovieIndex\";\r\n\tko.components.register(componentName, {\r\n\t\tviewModel: function () {\r\n\t\t\tvar model = movieSvc.getMovies();\r\n\r\n\t\t\treturn model;\r\n\t\t},\r\n\t\ttemplate: { require: \"text!Templates/MovieIndex.html\" }\r\n\t});\r\n\r\n\treturn {\r\n\t\turlTemplate: \"index\",\r\n\t\tname: componentName\r\n\t};\r\n});\n",
    "define('Components/MovieDetail',[\"knockout\", \"MyKoUtils\", \"Data/Movies\", \"komapping\"], function (ko, myKoUtils, movieSvc) {\r\n\t\"use strict\";\r\n\r\n\tvar componentName = \"MovieDetail\";\r\n\tko.components.register(componentName, {\r\n\t\tviewModel: function (params) {\r\n\r\n\t\t\tvar isInEditMode = ko.observable(false);\r\n\t\t\tvar storedMovie = movieSvc.getMovie(params.id);\r\n\t\t\tvar editMovie = myKoUtils.copy(storedMovie);\r\n\r\n\t\t\tvar model = {\r\n\t\t\t\tmovie: storedMovie,\r\n\t\t\t\t//editMovie: editMovie,\r\n\t\t\t\tedit: function () {\r\n\t\t\t\t\teditMovie = myKoUtils.copy(storedMovie);\r\n\t\t\t\t\tisInEditMode(true);\r\n\t\t\t\t},\r\n\t\t\t\tsave: function () {\r\n\t\t\t\t\tmovieSvc.updateMovie(editMovie);\r\n\t\t\t\t\tisInEditMode(false);\r\n\t\t\t\t},\r\n\t\t\t\tcancel: function () {\r\n\t\t\t\t\tmyKoUtils.mergeInto(storedMovie, editMovie);\r\n\t\t\t\t\tisInEditMode(false);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\treturn model;\r\n\t\t},\r\n\t\ttemplate: { require: \"text!Templates/MovieDetail.html\" }\r\n\t});\r\n\r\n\treturn {\r\n\t\turlTemplate: \"movie/:id\",\r\n\t\tname: componentName\r\n\t};\r\n});\n",
    "/// <reference path=\"../bower_components/requirejs/require.js\" />\r\nrequire.config({\r\n\tbaseUrl: \"/scripts\",\r\n\tpaths: {\r\n\t\tdomready: \"../bower_components/requirejs-domready/domready\",\r\n\t\ttext: \"../bower_components/requirejs-text/text\",\r\n\t\tknockout: \"../bower_components/knockout/dist/knockout\",\r\n\t\tkomapping: \"../bower_components/knockout-mapping/build/output/knockout.mapping-latest\",\r\n\t\tkoprojections: \"../bower_components/knockout-projections/dist/knockout-projections\",\r\n\t\tjquery: \"../bower_components/jquery/dist/jquery\",\r\n\t\tgrapnel: \"../bower_components/grapnel/dist/grapnel.min\",\r\n\t\tlodash: \"../bower_components/lodash/dist/lodash\"\r\n\t},\r\n\tshim: {\r\n\t\tkomapping: [\"knockout\"],\r\n\t\tkoprojections: [\"knockout\"],\r\n\t\tjquery: { exports: \"$\" },\r\n\t}\r\n});\r\n\r\n\r\n\r\nrequire([\"grapnel\", \"knockout\", \"withLookups\", \"domready!\"], function (grapnel, ko, setupWithLookups) {\r\n\t\"use strict\";\r\n\r\n\tsetupWithLookups();\r\n\r\n\tko.components.register(\"NotFound\", { template: \"Page Not Found!\" });\r\n\r\n\tvar currentComponentNameAndParams = ko.observable(null);\r\n\r\n\tvar vm = {\r\n\t\tcomponent: currentComponentNameAndParams\r\n\t};\r\n\tko.applyBindings(vm);\r\n\r\n\r\n\tvar router = new grapnel.Router();\r\n\trouter.get(\"\", function () {\r\n\t\trouter.anchor.set(\"/index\");\r\n\t});\r\n\r\n\r\n\trequire([\r\n\t\t\"Components/MovieIndex\",\r\n\t\t\"Components/MovieDetail\"\r\n\t], function () {\r\n\t\trouter.get(\"*\", function () {\r\n\t\t\tcurrentComponentNameAndParams({ name: \"NotFound\", params: {} });\r\n\t\t});\r\n\r\n\t\t// This function is there to capture each closure, and not just the last one... (Could be written as an IFEE)\r\n\t\tvar fn = (function (component) {\r\n\t\t\trouter.get('/' + component.urlTemplate, function (req) {\r\n\t\t\t\tcurrentComponentNameAndParams({ name: component.name, params: req.params });\r\n\t\t\t});\r\n\t\t});\r\n\r\n\t\t// arguments here is a list of components to load (See the function we're in, inside the require statement)\r\n\t\tfor (var i = 0; i < arguments.length; i++) {\r\n\r\n\t\t\tfn(arguments[i]);\r\n\t\t}\r\n\t});\r\n});\r\n\ndefine(\"Main\", function(){});\n\n"
  ]
}